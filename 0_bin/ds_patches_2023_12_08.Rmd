---
title: "Untitled"
output: html_document
date: "2023-12-08"
---

```{r}

# This is the old code. 

#Assemble the dataset. When importing the data, each row is a video.
  time_points_ds = NULL
  for (time_point_input in time_points) {
    
    #File paths
    pop_data_file_path = here("data", "population", paste0("t", time_point_input, ".csv"))
    Ble_ID_file_path = here("data","species_ID_Ble_analysis", paste0("species_ID_t", time_point_input, ".csv"))
    main_ID_file_path = here("data", "species_ID_main_analysis", paste0("species_ID_t", time_point_input, ".csv"))
    
    #Import data
    species_ID_Ble = read.csv(Ble_ID_file_path) %>%
      select(file,
             Ble,
             Cep,
             Spi)
    
    species_ID_main = read.csv(main_ID_file_path) %>%
      select(file,
             Ble:Tet) %>%
      rename(
        Ble_main_analysis = Ble,
        Cep_main_analysis = Cep,
        Spi_main_analysis = Spi
      )
    
    #Merge data
    time_points_ds[[time_point_input + 1]] = read.csv(pop_data_file_path) %>%
      left_join(species_ID_Ble,
                by = "file") %>%
      left_join(species_ID_main,
                by = "file")
    
    #Initially, at time point 0, 12 videos were captured of the large bottle from which the community was assembled. In order to analyze the data, each of these 12 videos are assigned to each culture.
    if (time_point_input == 0) {
      
      #Parameters
      n_videos = nrow(time_points_ds[[time_point_input + 1]])
      n_cultures = nrow(culture_info)
      
      #Elongate
      time_points_ds[[time_point_input + 1]] = map_dfr(1:n_cultures, ~ time_points_ds[[time_point_input + 1]]) %>%
        arrange(file) %>%
        mutate(culture_ID = rep(1:n_cultures, times = n_videos_taken_t0))
      
    }
    
    #Add the video replicate which I forgot to put into the description file 
    if(time_point_input == 0){
      time_points_ds[[time_point_input + 1]]$video_replicate = 1:12
    }
    
    if(time_point_input %in% 1:5){
      time_points_ds[[time_point_input + 1]]$video_replicate = 1
    }
    
    if(time_point_input %in% 6:7){
      time_points_ds[[time_point_input + 1]]$video_replicate = rep(1:2, each = 110)
    }
    
    #Manipulate columns
    time_points_ds[[time_point_input + 1]] = time_points_ds[[time_point_input + 1]] %>%
      mutate(time_point = time_point_input,
             day = sampling_days[(time_point_input + 1)],
             file = as.double(str_extract(file, "\\d+"))) %>%
      select(
        time_point,
        day,
        file,
        video_replicate,
        culture_ID,
        bioarea_per_volume,
        indiv_per_volume,
        Ble,
        Cep,
        Col,
        Eug,
        Eup,
        Lox,
        Pau,
        Pca,
        Spi,
        Spi_te,
        Tet,
        Ble_main_analysis,
        Cep_main_analysis,
        Spi_main_analysis
      )
    
  }
  
    ds_patches = time_points_ds %>%
    bind_rows() %>%
    left_join(culture_info,
              by = "culture_ID") 
```

```{r}
#Import protist population data
ds_patches = import.protist.pop.data(culture_info,
                                     time_points,
                                     protist_species)

expect_equal(nrow(ds_patches), 
             sum(nr_videos * n_cultures))
```

```{r}
#Reorder dataset
ds_patches = ds_patches %>%
  select(time_point,
         day,
         file,
         video_replicate,
         culture_ID,
         system_nr,
         disturbance,
         eco_metaeco_type,
         patch_size,
         patch_size_volume,
         metaecosystem,
         metaecosystem_type,
         bioarea_per_volume,
         all_of(protist_species),
         Ble_main_analysis,
         Cep_main_analysis,
         Spi_main_analysis)

expect_equal(nrow(ds_patches), 
             sum(nr_videos * n_cultures))
```

```{r}
#Take off problematic videos
ds_patches = ds_patches %>%
  filter(!(time_point %in% videos_to_take_off$time_point & 
           file %in% videos_to_take_off$file))

expect_equal(nrow(ds_patches),
             sum(nr_videos * n_cultures) - nrow(videos_to_take_off))
```

```{r}
#Take off problematic cultures 
ds_patches = ds_patches %>%
  filter(! culture_ID %in% patches_to_take_off)

expect_equal(nrow(ds_patches),
               sum(nr_videos * n_cultures) - nrow(videos_to_take_off) - (length(patches_to_take_off) * sum(nr_videos)))

if(TRUE %in% unique(videos_to_take_off$culture_ID == patches_to_take_off)){
  stop("Adjust your testing code, as the number of rows should consider that videos to take off are also in the patches to take off.")
}
```

```{r}
#Rename columns
  ds_patches = ds_patches %>%
    rename(
      patch_type = eco_metaeco_type,
      bioarea_µm2_per_μL = bioarea_per_volume,
      patch_size_ml = patch_size_volume
    ) %>%
    rename_with( ~ paste0(., "_indiv_per_μL"), any_of(
      c(
        protist_species,
        "Ble_low_threshold_analysis",
        "Cep_low_threshold_analysis",
        "Spi_low_threshold_analysis"
      )
    ))
```

```{r}
#Rename patches
ds_patches$patch_type <- recode(
  ds_patches$patch_type,
  "S" = "Small isolated",
  "S (S_S)" = "Small connected to small",
  "S (S_L)" = "Small connected to large",
  "M" = "Medium isolated",
  "M (M_M)" = "Medium connected to medium",
  "L" = "Large isolated",
  "L (L_L)" = "Large connected to large",
  "L (S_L)" = "Large connected to small"
)
```

```{r}
#Rename patch sizes
ds_patches$patch_size <- recode(
  ds_patches$patch_size,
  "S" = "Small",
  "M" = "Medium",
  "L" = "Large"
)
```

```{r}
#Rename meta-ecosystems
ds_patches$metaecosystem_type <- recode(
  ds_patches$metaecosystem_type,
  "S_S" = "Small-Small meta-ecosystem",
  "M_M" = "Medium-Medium meta-ecosystem",
  "L_L" = "Large-Large meta-ecosystem",
  "S_L" = "Small-Large meta-ecosystem"
)
```

```{r}
#Reorder patches
patch_types_ordered = c(
      "Small isolated",
      "Small connected to small",
      "Small connected to large",
      "Medium isolated",
      "Medium connected to medium",
      "Large isolated",
      "Large connected to large",
      "Large connected to small"
    )

ds_patches = ds_patches %>%
  mutate(patch_type = factor(
    patch_type,
    levels = patch_types_ordered
  ))
```

```{r}
#Reorder meta-ecosystems
ds_patches = ds_patches %>%
  mutate(metaecosystem_type = factor(
    metaecosystem_type,
    levels = c(
      "Small-Small meta-ecosystem",
      "Medium-Medium meta-ecosystem",
      "Medium-Medium isolated",
      "Large-Large meta-ecosystem",
      "Small-Large meta-ecosystem",
      "Small-Large isolated"
    )
  ))
```

```{r}
#Add column of the size of the connected patch
ds_patches$size_connected_patch = NA
ds_patches$size_connected_patch[ds_patches$patch_type == "Small connected to small"] = "Small"
ds_patches$size_connected_patch[ds_patches$patch_type == "Small connected to large"] = "Large"
ds_patches$size_connected_patch[ds_patches$patch_type == "Medium connected to medium"] = "Medium"
ds_patches$size_connected_patch[ds_patches$patch_type == "Large connected to large"] = "Large"
ds_patches$size_connected_patch[ds_patches$patch_type == "Large connected to small"] = "Small"
```

```{r}
#Change all the measures to ml
ds_patches = ds_patches %>%
  mutate(bioarea_µm2_per_ml = bioarea_µm2_per_μL * 10^3,
         bioarea_mm2_per_ml = bioarea_µm2_per_ml * 10^(-6),
         Ble_indiv_per_ml = Ble_indiv_per_μL * 10^3,
         Cep_indiv_per_ml = Cep_indiv_per_μL * 10^3,
         Col_indiv_per_ml = Col_indiv_per_μL * 10^3,
         Eug_indiv_per_ml = Eug_indiv_per_μL * 10^3,
         Eup_indiv_per_ml = Eup_indiv_per_μL * 10^3,
         Lox_indiv_per_ml = Lox_indiv_per_μL * 10^3,
         Pau_indiv_per_ml = Pau_indiv_per_μL * 10^3,
         Pca_indiv_per_ml = Pca_indiv_per_μL * 10^3,
         Spi_indiv_per_ml = Spi_indiv_per_μL * 10^3,
         Spi_te_indiv_per_ml = Spi_te_indiv_per_μL * 10^3,
         Tet_indiv_per_ml = Tet_indiv_per_μL * 10^3)
```

```{r}
#Rearrange columns
ds_patches = ds_patches %>%
  select(time_point,
         day,
         file,
         video_replicate,
         culture_ID,
         system_nr,
         disturbance,
         patch_type,
         patch_size,
         patch_size_ml,
         size_connected_patch,
         metaecosystem,
         metaecosystem_type,
         bioarea_mm2_per_ml,
         all_of(protist_species_indiv_per_ml))
```

```{r}
### Average videos
ds_patches = ds_patches %>%
  group_by(across(all_of(columns_patches))) %>%
  summarise(across(contains("_per_ml"), mean),
            across(contains("_tot"), mean)) %>%
  ungroup()

expect_equal(nrow(ds_patches),
             (n_cultures - length(patches_to_take_off)) * length(time_points))
```

```{r}
#Calculate individuals per ml (based on a combination of the two analyses - one with low and one with high thresholds). 
ds_patches = ds_patches %>%
  mutate(indiv_per_ml = !!rlang::parse_expr(paste(paste0(protist_species, "_indiv_per_ml"), collapse = " + ")))
```

```{r}
#Calculate total response variable for the whole patch
ds_patches = ds_patches %>%
  mutate(bioarea_tot_mm2 = bioarea_mm2_per_ml * patch_size_ml,
         indiv_tot = indiv_per_ml * patch_size_ml,
         Ble_tot_indiv = Ble_indiv_per_ml * patch_size_ml,
         Cep_tot_indiv = Cep_indiv_per_ml * patch_size_ml,
         Col_tot_indiv = Col_indiv_per_ml * patch_size_ml,
         Eug_tot_indiv = Eug_indiv_per_ml * patch_size_ml,
         Eup_tot_indiv = Eup_indiv_per_ml * patch_size_ml,
         Lox_tot_indiv = Lox_indiv_per_ml * patch_size_ml,
         Pau_tot_indiv = Pau_indiv_per_ml * patch_size_ml,
         Pca_tot_indiv = Pca_indiv_per_ml * patch_size_ml,
         Spi_tot_indiv = Spi_indiv_per_ml * patch_size_ml,
         Spi_te_tot_indiv = Spi_te_indiv_per_ml * patch_size_ml,
         Tet_tot_indiv = Tet_indiv_per_ml * patch_size_ml)
```

```{r}
#Calculate species dominance
ds_patches = ds_patches %>%
  mutate(across(all_of(protist_species_indiv_per_ml), 
                list(dominance = ~ (. / indiv_per_ml) * 100), 
                .names = "{col}_dominance"))

expect_equal(unique(ds_patches$Ble_indiv_per_ml_dominance[ds_patches$indiv_per_ml == 0]),
             NaN)
```

```{r}
#Keep the number of rows before calculations
n_rows_ds_patches_before_calculations = nrow(ds_patches)
```

```{r}
#Calculate alpha diversity (Shannon, Simpson, Inverse Simpson, Evenness)
ds_patches = calculate.alpha.diversity()

ds_patches$shannon[ds_patches$species_richness == 1] = 0 #I'm not sure why this is not already done automatically in the previous step 

expect_equal(max(ds_patches$species_richness),
             n_protist_species)
```

```{r}
#Calculate median body size
ds_median_body_size = ds_individuals %>%
  group_by(time_point,
           culture_ID,
           file) %>%
  summarise(median_body_area_µm2 = median(body_area_µm2)) %>%
  group_by(time_point,
           culture_ID) %>%
  summarise(median_body_area_µm2 = mean(median_body_area_µm2))

expect_true(nrow(ds_median_body_size) <= nrow(ds_patches))

ds_patches = full_join(ds_patches, ds_median_body_size)

expect_equal(nrow(ds_patches),
             n_rows_ds_patches_before_calculations)
```

```{r}
#Calculate baselines. To consider the initial values for different cultures when analyzing their temporal trends, we add baselines from time point 1. These baselines are used because at time point 0, we only measured the community of the large bottle that the experiment was assembled from. Additionally, the first perturbation had already occurred by time point 2, which is the starting point for our models.
baselines <- ds_patches %>%
  filter(time_point == 1) %>%
  group_by(culture_ID) %>%
  summarise(across(all_of(variables_patches), 
                   .names = "baseline_{.col}"))

ds_patches = full_join(ds_patches, baselines)

expect_equal(nrow(ds_patches),
             n_rows_ds_patches_before_calculations)
```

```{r}
#Calculate in each culture when was the time we saw of the protis species
protist_last_saw_columns = paste0(protist_species, "_last_saw_day")

for(culture_ID_input in 1:n_cultures){
  for(protist_input in protist_species){
    
    protist_density_column = paste0(protist_input, "_indiv_per_ml")
    protist_last_saw_column = paste0(protist_input, "_last_saw_day")
    
    day_last_saw = ds_patches %>%
      filter(culture_ID == culture_ID_input) %>%
      select(day,
             all_of(protist_density_column)) %>%
      slice(which.max(.data[[protist_density_column]])) %>%
      pull(day)
    
    ds_patches[[protist_last_saw_column]][ds_patches$culture_ID == culture_ID_input] = day_last_saw
  }
}
```

```{r}
#Reorder columns 
ds_patches = ds_patches %>%
  select(any_of(c(
    columns_patches,
    variables_patches,
    baseline_columns,
    protist_last_saw_columns
  )))
```