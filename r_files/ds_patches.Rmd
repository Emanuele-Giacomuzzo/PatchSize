---
title: "Data manipulation: PatchSizePilot"
author: "Emanuele Giacomuzzo"
date: "2022-08-04"
output: html_document
editor_options: 
  chunk_output_type: console
---

-   Every row is a patch at a certain time point.
-   The value of different videos have been already averaged.

```{r}
#Assemble the dataset. When importing the data, each row is a video.
#Watch out:  This is because we wanted to be able to identify Tet, but that meant that we couldn't get rid of the food of Ble (food was Chi). This is why we ran two analysis. The first analysis was the main analysis keeping the Ble food and Tet. This allowed us to identify and quantify all species but Ble. The second analysis was the Ble analysis getting rid of both the food of Ble and Tet. This allowed us to identify and quantify Ble. Because of this, I call the Ble of the main analsysis a Ble_biased. 
time_points_ds = NULL
for (time_point in first_time_point:last_time_point) {
  
  load(here("data", "population", paste0("t",time_point,".RData")))
  
  time_points_ds[[time_point+1]] = pop_output %>%
    left_join(read.csv(here("data", "species_ID_Ble_analysis", paste0("species_ID_t", time_point, ".csv"))) %>%
                select(file,
                       Ble),
              by = "file") %>%
    left_join(read.csv(here("data", "species_ID_main_analysis", paste0("species_ID_t", time_point, ".csv"))) %>%
                select(file,
                       Ble:Tet) %>%
                rename(Ble_biased = Ble),
              by = "file")
  
  #Write here
  if(time_point == 0) {
    
    time_points_ds[[time_point+1]] = time_points_ds[[time_point+1]][rep(row.names(pop_output),
                                                                        nrow(culture_info)), ] %>%
      arrange(file) %>%
      mutate(culture_ID = rep(1 :n_cultures,
                              times = n_videos_taken_t0))
  }
  
  time_points_ds[[time_point+1]] = time_points_ds[[time_point+1]] %>%
    select(file,
           culture_ID,
           bioarea_per_volume,
           indiv_per_volume,
           protist_species[1]:protist_species[n_protist_species]) %>%
    mutate(time_point = time_point,
           day = sampling_days[time_point + 1])
  
}


#Bind everything together
ds_patches = time_points_ds %>%
  bind_rows() %>%
  left_join(culture_info,
            by = "culture_ID") 

#Rename columns 
ds_patches = ds_patches %>%
  rename(indiv_per_μL = indiv_per_volume,
         bioarea_per_μL = bioarea_per_volume) %>%
  rename_with( ~ paste0(., "_indiv_per_μL"), first_protist:last_protist)
```

```{r eval = FALSE}

### --- CHECK THAT THE SPECIES ID WORKED PROPERLY --- ###
volume_recorded_μl = 34.4

#Check that all individuals have been identified in the species ID script.
ds_patches %>%
  mutate(
    indiv_identified_per_μL =
      Ble_biased_indiv_per_μL +
      Cep_indiv_per_μL +
      Col_indiv_per_μL +
      Eug_indiv_per_μL +
      Eup_indiv_per_μL +
      Lox_indiv_per_μL +
      Pau_indiv_per_μL +
      Pca_indiv_per_μL +
      Spi_indiv_per_μL +
      Spi_te_indiv_per_μL +
      Tet_indiv_per_μL,
    individuals_not_identified = indiv_per_μL - indiv_identified_per_μL
  ) %>%
  select(individuals_not_identified) %>%
  pull() %>%
  hist()

#Create dataset where we have the number of individuals for each species in each video. This can be used to look at the videos and see if the number of individuals make sense.
t = NULL
for(time_point in first_time_point:last_time_point){
  
  t[[time_point + 1]] = read.csv(here(
    "data",
    "species_ID_main_analysis",
    paste0("species_ID_t", time_point, ".csv")
  )) %>%
    select(file,
           first_protist:last_protist) %>%
    rename_with( ~ paste0(., "_indiv_per_μL"), first_protist:last_protist) %>%
    mutate(
      time_point = time_point,
      Ble_indiv_per_video = Ble_indiv_per_μL * volume_recorded_μl,
      Cep_indiv_per_video = Cep_indiv_per_μL * volume_recorded_μl,
      Col_indiv_per_video = Col_indiv_per_μL * volume_recorded_μl,
      Eug_indiv_per_video = Eug_indiv_per_μL * volume_recorded_μl,
      Eup_indiv_per_video = Eup_indiv_per_μL * volume_recorded_μl,
      Lox_indiv_per_video = Lox_indiv_per_μL * volume_recorded_μl,
      Pau_indiv_per_video = Pau_indiv_per_μL * volume_recorded_μl,
      Pca_indiv_per_video = Pca_indiv_per_μL * volume_recorded_μl,
      Spi_indiv_per_video = Spi_indiv_per_μL * volume_recorded_μl,
      Spi_indiv_te_per_video = Spi_te_indiv_per_μL * volume_recorded_μl,
      Tet_indiv_per_video = Tet_indiv_per_μL * volume_recorded_μl
    )
}

t = t %>%
  bind_rows() %>%
  select(time_point,
         file,
         Ble_indiv_per_video: Tet_indiv_per_video)
```

```{r}
#Rename patches
ds_patches$patch_type <- recode(
  ds_patches$eco_metaeco_type,
  "S" = "Small isolated",
  "S (S_S)" = "Small connected to small",
  "S (S_L)" = "Small connected to large",
  "M" = "Medium isolated",
  "M (M_M)" = "Medium connected to medium",
  "L" = "Large isolated",
  "L (L_L)" = "Large connected to large",
  "L (S_L)" = "Large connected to small"
)
```

```{r}
#Reorder patches
ds_patches = ds_patches %>%
  mutate(patch_type = factor(
    patch_type,
    levels = c(
      "Small isolated",
      "Small connected to small",
      "Small connected to large",
      "Medium isolated",
      "Medium connected to medium",
      "Large isolated",
      "Large connected to large",
      "Large connected to small"
    )
  ))
```

```{r}
ds_patches$size_of_the_connected_patch = NA
ds_patches$size_of_the_connected_patch[ds_patches$patch_type == "Small connected to small"] = "Small"
ds_patches$size_of_the_connected_patch[ds_patches$patch_type == "Small connected to large"] = "Large"
ds_patches$size_of_the_connected_patch[ds_patches$patch_type == "Medium connected to medium"] = "Medium"
ds_patches$size_of_the_connected_patch[ds_patches$patch_type == "Large connected to large"] = "Large"
ds_patches$size_of_the_connected_patch[ds_patches$patch_type == "Large connected to small"] = "Small"
```

```{r}
#Filter out problematic cultures 
ds_patches = ds_patches %>%
  filter(! culture_ID %in% patches_to_take_off)
```

```{r}
### Average videos (gets rid of useless columns)
ds_patches = ds_patches %>%
  group_by(
    culture_ID,
    patch_size,
    patch_size_volume,
    size_of_the_connected_patch,
    disturbance,
    metaecosystem_type,
    time_point,
    day,
    metaecosystem,
    system_nr,
    patch_type
  ) %>%
  summarise(
    bioarea_per_volume = mean(bioarea_per_volume),
    indiv_per_μL = mean(indiv_per_μL),
    Ble = mean(Ble),
    Cep = mean(Cep),
    Col = mean(Col),
    Eug = mean(Eug),
    Eup = mean(Eup),
    Lox = mean(Lox),
    Pau = mean(Pau),
    Pca = mean(Pca),
    Spi = mean(Spi),
    Spi_te = mean(Spi_te),
    Tet = mean(Tet)
  ) %>%
  rename(patch_size_ml = patch_size_volume) %>%
  mutate(indiv_identified_per_μL = Ble + Cep + Col + Eug + Eup + Lox + Pau + Pca + Spi + Spi_te + Tet) %>%
  ungroup()
```

```{r}
#Change all the measures to ml
#1. To convert bioarea_per_volume from µm2/µl to µm2/ml, multiply by 1000
#2. To convert indiv_per_μL from µm2/µl to µm2/ml, multiply by 1000
#3. To convert protists (Ble to Tet) from individuals/µl to individuals/ml, multiply by 1000
ds_patches = ds_patches %>%
  mutate(bioarea_per_ml = bioarea_per_volume * 1000,
         indiv_per_ml = indiv_per_μL * 1000,
         indiv_per_ml_Lynn = indiv_identified_per_μL * 1000,
         Ble = Ble * 1000,
         Cep = Cep * 1000,
         Col = Col * 1000,
         Eug = Eug * 1000,
         Eup = Eup * 1000,
         Lox = Lox * 1000,
         Pau = Pau * 1000,
         Pca = Pca * 1000,
         Spi = Spi * 1000,
         Spi_te = Spi_te * 1000,
         Tet = Tet * 1000)
```

```{r}
#Calculate total response variable for the whole patch
ds_patches = ds_patches %>%
  mutate(bioarea_tot = bioarea_per_ml * patch_size_ml,
         indiv_tot = indiv_per_ml * patch_size_ml,
         Ble_tot = Ble * patch_size_ml,
         Cep_tot = Cep * patch_size_ml,
         Col_tot = Col * patch_size_ml,
         Eug_tot = Eug * patch_size_ml,
         Eup_tot = Eup * patch_size_ml,
         Lox_tot = Lox * patch_size_ml,
         Pau_tot = Pau * patch_size_ml,
         Pca_tot = Pca * patch_size_ml,
         Spi_tot = Spi * patch_size_ml,
         Spi_te_tot = Spi_te * patch_size_ml,
         Tet_tot = Tet * patch_size_ml)
```

```{r}
#Calculate species dominance
ds_patches = ds_patches %>%
  mutate(Ble_dominance = (Ble / indiv_per_ml_Lynn) * 100,
         Cep_dominance = (Cep / indiv_per_ml_Lynn) * 100,
         Col_dominance = (Col / indiv_per_ml_Lynn) * 100,
         Eug_dominance = (Eug / indiv_per_ml_Lynn) * 100,
         Eup_dominance = (Eup  / indiv_per_ml_Lynn) * 100,
         Lox_dominance = (Lox / indiv_per_ml_Lynn) * 100,
         Pau_dominance = (Pau / indiv_per_ml_Lynn) * 100,
         Pca_dominance = (Pca / indiv_per_ml_Lynn) * 100,
         Spi_dominance = (Spi / indiv_per_ml_Lynn) * 100,
         Spi_te_dominance = (Spi_te / indiv_per_ml_Lynn) * 100,
         Tet_dominance = (Tet / indiv_per_ml_Lynn) * 100)
```

```{r calculate_alpha_diversity_(ds_patches)}

#Calculate alpha diversity (shannon, simpson, inv simpson, evenness)
ds_patches$species_richness = NA
ds_patches$shannon = NA
ds_patches$simpson = NA
ds_patches$inv_simpson = NA
ds_patches$evenness_pielou = NA

for (row in 1:nrow(ds_patches)) {
  
  species_vector = ds_patches %>%
    slice(row) %>%
    select(protist_species[1]:protist_species[n_protist_species])
  
  ds_patches[row,]$species_richness = species_vector %>%
    mutate_at(vars(protist_species),
              funs(ifelse(. > 0,
                          yes = 1,
                          no = 0))) %>%
    rowSums()
  
  ds_patches[row, ]$simpson = diversity(species_vector,
                                        index = "simpson")
  
  ds_patches[row, ]$shannon = diversity(species_vector,
                                        index = "shannon")
  
  ds_patches[row, ]$inv_simpson = diversity(species_vector,
                                            index = "invsimpson")
  
  ds_patches[row, ]$evenness_pielou = diversity(species_vector) / 
                                      log(specnumber(species_vector))
  
}
```

```{r}
#Compute divergence from isolated. This is the difference in community composition of each culture from the other isolated cultures (Bray-Curtis)
ds_patches$beta_diversity_from_isolated = NA
for (disturbance in c("low", "high")){
  for (time_point_input in first_time_point:last_time_point) {
    for(treatment_input in c("Small connected to large", "Large connected to small")){
      
      if(treatment_input == "Small connected to large"){control_input = "Small isolated"}
      if(treatment_input == "Large connected to small"){control_input = "Large isolated"}
      
      treatment_group = ds_patches %>%
        filter(patch_type %in% treatment_input,
               time_point == time_point_input,
               disturbance == disturbance) %>%
        select(culture_ID, 
               first_protist:last_protist)
      
      control_group = ds_patches %>%
        filter(patch_type %in% control_input,
               time_point == time_point_input,
               disturbance == disturbance) %>%
        select(culture_ID, 
               first_protist:last_protist)
      
      pairwise_bray_curtis = NA
      row = 0
      for(treatment_iteration in 1:nrow(treatment_group)){
        for(control_iteration in 1:nrow(control_group)){
          
          row = row + 1
          
          pairwise_bray_curtis[row] <- vegdist(rbind(treatment_group[treatment_iteration, -1], 
                                                     control_group[control_iteration, -1]), 
                                               method = "bray") %>%
            as.numeric()
          
        }
        
        mean_bray_curtis = mean(pairwise_bray_curtis)
        
        ds_patches$beta_diversity_from_isolated[
          ds_patches$culture_ID ==  treatment_group$culture_ID[treatment_iteration] &
          ds_patches$time_point == time_point_input] = 
        mean_bray_curtis
        
      }
    }
  }
}
```

```{r}
#Compute temporal divergence. This is the difference in community composition of each culture from its previous time point (Bray-Curtis)
ds_patches$beta_diversity_from_previous_time = NA
for(culture_ID_input in 1:n_cultures) {
  for(time_point_input in first_time_point + 1 :last_time_point){
    
    bray_curtis = ds_patches %>%
    filter(
      culture_ID == culture_ID_input,
      time_point %in% c(time_point_input, time_point_input - 1)
    ) %>%
    select(first_protist:last_protist) %>%
    vegdist(.,
            method = "bray")
  
  ds_patches$beta_diversity_from_previous_time[ds_patches$culture_ID == culture_ID_input &
                                                 ds_patches$time_point == time_point_input] = bray_curtis
    
  }
}
```

```{r}
#To consider the initial values for different cultures when analyzing their temporal trends, we add baselines from time point 1. These baselines are used because at time point 0, we only measured the community of the large bottle that the experiment was assembled from. Additionally, the first perturbation had already occurred by time point 2, which is the starting point for our models.
baselines <- ds_patches %>%
  filter(time_point == 1) %>%
  group_by(culture_ID) %>%
  summarise(across(vars, .names = "baseline_{.col}"))

ds_patches = full_join(ds_patches, baselines)
```
