---
title: "Data manipulation: PatchSizePilot"
author: "Emanuele Giacomuzzo"
date: "2022-08-04"
output: html_document
editor_options: 
  chunk_output_type: console
---

After the dataset has been assembled

-   Every row is a patch at a certain time point.
-   The value of different videos have been already averaged.

```{r}
#Import protist population data
ds_patches = import.protist.pop.data(culture_info,
                                     time_points,
                                     protist_species)

expect_equal(nrow(ds_patches), 
             sum(nr_videos * n_cultures))
```

```{r}
#Reorder dataset
ds_patches = ds_patches %>%
  select(time_point,
         day,
         file,
         video_replicate,
         culture_ID,
         system_nr,
         disturbance,
         eco_metaeco_type,
         patch_size,
         patch_size_volume,
         metaecosystem,
         metaecosystem_type,
         bioarea_per_volume,
         all_of(protist_species),
         Ble_main_analysis,
         Cep_main_analysis,
         Spi_main_analysis)

expect_equal(nrow(ds_patches), 
             sum(nr_videos * n_cultures))
```

```{r}
#Take off problematic videos
ds_patches = ds_patches %>%
  filter(!(time_point %in% videos_to_take_off$time_point & 
           file %in% videos_to_take_off$file))

expect_equal(nrow(ds_patches),
             sum(nr_videos * n_cultures) - nrow(videos_to_take_off))
```

```{r}
#Take off problematic cultures 
ds_patches = ds_patches %>%
  filter(! culture_ID %in% patches_to_take_off)

expect_equal(nrow(ds_patches),
               sum(nr_videos * n_cultures) - nrow(videos_to_take_off) - (length(patches_to_take_off) * sum(nr_videos)))

if(TRUE %in% unique(videos_to_take_off$culture_ID == patches_to_take_off)){
  stop("Adjust your testing code, as the number of rows should consider that videos to take off are also in the patches to take off.")
}
```

```{r}
#Rename columns
  ds_patches = ds_patches %>%
    rename(
      patch_type = eco_metaeco_type,
      bioarea_µm2_per_μL = bioarea_per_volume,
      patch_size_ml = patch_size_volume
    ) %>%
    rename_with( ~ paste0(., "_indiv_per_μL"), any_of(
      c(
        protist_species,
        "Ble_low_threshold_analysis",
        "Cep_low_threshold_analysis",
        "Spi_low_threshold_analysis"
      )
    ))
```

```{r}
#Rename patches
ds_patches$patch_type <- recode(
  ds_patches$patch_type,
  "S" = "Small isolated",
  "S (S_S)" = "Small connected to small",
  "S (S_L)" = "Small connected to large",
  "M" = "Medium isolated",
  "M (M_M)" = "Medium connected to medium",
  "L" = "Large isolated",
  "L (L_L)" = "Large connected to large",
  "L (S_L)" = "Large connected to small"
)
```

```{r}
#Rename patch sizes
ds_patches$patch_size <- recode(
  ds_patches$patch_size,
  "S" = "Small",
  "M" = "Medium",
  "L" = "Large"
)
```

```{r}
#Rename meta-ecosystems
ds_patches$metaecosystem_type <- recode(
  ds_patches$metaecosystem_type,
  "S_S" = "Small-Small meta-ecosystem",
  "M_M" = "Medium-Medium meta-ecosystem",
  "L_L" = "Large-Large meta-ecosystem",
  "S_L" = "Small-Large meta-ecosystem"
)
```

```{r}
#Reorder patches
patch_types_ordered = c(
      "Small isolated",
      "Small connected to small",
      "Small connected to large",
      "Medium isolated",
      "Medium connected to medium",
      "Large isolated",
      "Large connected to large",
      "Large connected to small"
    )

ds_patches = ds_patches %>%
  mutate(patch_type = factor(
    patch_type,
    levels = patch_types_ordered
  ))
```

```{r}
#Reorder meta-ecosystems
ds_patches = ds_patches %>%
  mutate(metaecosystem_type = factor(
    metaecosystem_type,
    levels = c(
      "Small-Small meta-ecosystem",
      "Medium-Medium meta-ecosystem",
      "Medium-Medium isolated",
      "Large-Large meta-ecosystem",
      "Small-Large meta-ecosystem",
      "Small-Large isolated"
    )
  ))
```

```{r}
#Add column of the size of the connected patch
ds_patches$size_connected_patch = NA
ds_patches$size_connected_patch[ds_patches$patch_type == "Small connected to small"] = "Small"
ds_patches$size_connected_patch[ds_patches$patch_type == "Small connected to large"] = "Large"
ds_patches$size_connected_patch[ds_patches$patch_type == "Medium connected to medium"] = "Medium"
ds_patches$size_connected_patch[ds_patches$patch_type == "Large connected to large"] = "Large"
ds_patches$size_connected_patch[ds_patches$patch_type == "Large connected to small"] = "Small"
```

```{r}
#Change all the measures to ml
ds_patches = ds_patches %>%
  mutate(bioarea_µm2_per_ml = bioarea_µm2_per_μL * 10^3,
         bioarea_mm2_per_ml = bioarea_µm2_per_ml * 10^(-6),
         Ble_indiv_per_ml = Ble_indiv_per_μL * 10^3,
         Cep_indiv_per_ml = Cep_indiv_per_μL * 10^3,
         Col_indiv_per_ml = Col_indiv_per_μL * 10^3,
         Eug_indiv_per_ml = Eug_indiv_per_μL * 10^3,
         Eup_indiv_per_ml = Eup_indiv_per_μL * 10^3,
         Lox_indiv_per_ml = Lox_indiv_per_μL * 10^3,
         Pau_indiv_per_ml = Pau_indiv_per_μL * 10^3,
         Pca_indiv_per_ml = Pca_indiv_per_μL * 10^3,
         Spi_indiv_per_ml = Spi_indiv_per_μL * 10^3,
         Spi_te_indiv_per_ml = Spi_te_indiv_per_μL * 10^3,
         Tet_indiv_per_ml = Tet_indiv_per_μL * 10^3)
```

```{r}
#Rearrange columns
ds_patches = ds_patches %>%
  select(time_point,
         day,
         file,
         video_replicate,
         culture_ID,
         system_nr,
         disturbance,
         patch_type,
         patch_size,
         patch_size_ml,
         size_connected_patch,
         metaecosystem,
         metaecosystem_type,
         bioarea_mm2_per_ml,
         all_of(protist_species_indiv_per_ml))
```

```{r}
### Average videos
ds_patches = ds_patches %>%
  group_by(across(all_of(columns_patches))) %>%
  summarise(across(contains("_per_ml"), mean),
            across(contains("_tot"), mean)) %>%
  ungroup()

expect_equal(nrow(ds_patches),
             (n_cultures - length(patches_to_take_off)) * length(time_points))
```

```{r}
#Calculate individuals per ml (based on a combination of the two analyses - one with low and one with high thresholds). 
ds_patches = ds_patches %>%
  mutate(indiv_per_ml = !!rlang::parse_expr(paste(paste0(protist_species, "_indiv_per_ml"), collapse = " + ")))
```

```{r}
#Calculate total response variable for the whole patch
ds_patches = ds_patches %>%
  mutate(bioarea_tot_mm2 = bioarea_mm2_per_ml * patch_size_ml,
         indiv_tot = indiv_per_ml * patch_size_ml,
         Ble_tot_indiv = Ble_indiv_per_ml * patch_size_ml,
         Cep_tot_indiv = Cep_indiv_per_ml * patch_size_ml,
         Col_tot_indiv = Col_indiv_per_ml * patch_size_ml,
         Eug_tot_indiv = Eug_indiv_per_ml * patch_size_ml,
         Eup_tot_indiv = Eup_indiv_per_ml * patch_size_ml,
         Lox_tot_indiv = Lox_indiv_per_ml * patch_size_ml,
         Pau_tot_indiv = Pau_indiv_per_ml * patch_size_ml,
         Pca_tot_indiv = Pca_indiv_per_ml * patch_size_ml,
         Spi_tot_indiv = Spi_indiv_per_ml * patch_size_ml,
         Spi_te_tot_indiv = Spi_te_indiv_per_ml * patch_size_ml,
         Tet_tot_indiv = Tet_indiv_per_ml * patch_size_ml)
```

```{r}
#Calculate species dominance
ds_patches = ds_patches %>%
  mutate(across(all_of(protist_species_indiv_per_ml), 
                list(dominance = ~ (. / indiv_per_ml) * 100), 
                .names = "{col}_dominance"))

expect_equal(unique(ds_patches$Ble_indiv_per_ml_dominance[ds_patches$indiv_per_ml == 0]),
             NaN)
```

```{r}
#Keep the number of rows before calculations
n_rows_ds_patches_before_calculations = nrow(ds_patches)
```
```{r}
#Calculate alpha diversity (Shannon, Simpson, Inverse Simpson, Evenness)
ds_patches = calculate.alpha.diversity()

ds_patches$shannon[ds_patches$species_richness == 1] = 0 #I'm not sure why this is not already done automatically in the previous step 

expect_equal(max(ds_patches$species_richness),
             n_protist_species)
```

```{r eval = recompute_lengthy_analyses }
#Calculate divergence from isolated as Bray-Curtis.
ds_patches = calculate.treatment.divergence()

expect_true(max(ds_patches$beta_diversity_from_isolated, na.rm = T) <= 1)
expect_true(min(ds_patches$beta_diversity_from_isolated, na.rm = T) >= 0)

saveRDS(ds_patches, file = here("results", "ds_patches_w_treatment_divergence.RData"))
```

```{r}
#Read the dataset with the divergence from isolated
ds_patches = readRDS(here("results", "ds_patches_w_treatment_divergence.RData"))
```

Warning appear after the following code, as beta diversity is computed for a culture between when it totally crashed and its previous time point. Because the culture is totally crashed, the Bray-Curtis index is 1.

```{r}
#Calculate temporal divergence (Bray-Curtis). This is the difference in community composition of each culture from its previous time point.
ds_patches = calculate.temporal.divergence()

expect_true(max(ds_patches$beta_diversity_from_previous_time, na.rm = T) <= 1)
expect_true(min(ds_patches$beta_diversity_from_previous_time, na.rm = T) >= 0)
```

```{r}
#Calculate median body size
ds_median_body_size = ds_individuals %>%
  group_by(time_point,
           culture_ID,
           file) %>%
  summarise(median_body_area_µm2 = median(body_area_µm2)) %>%
  group_by(time_point,
           culture_ID) %>%
  summarise(median_body_area_µm2 = mean(median_body_area_µm2))

expect_true(nrow(ds_median_body_size) <= nrow(ds_patches))

ds_patches = full_join(ds_patches, ds_median_body_size)

expect_equal(nrow(ds_patches),
             n_rows_ds_patches_before_calculations)
```

```{r}
#Calculate baselines. To consider the initial values for different cultures when analyzing their temporal trends, we add baselines from time point 1. These baselines are used because at time point 0, we only measured the community of the large bottle that the experiment was assembled from. Additionally, the first perturbation had already occurred by time point 2, which is the starting point for our models.
baselines <- ds_patches %>%
  filter(time_point == 1) %>%
  group_by(culture_ID) %>%
  summarise(across(all_of(variables_patches), 
                   .names = "baseline_{.col}"))

ds_patches = full_join(ds_patches, baselines)

expect_equal(nrow(ds_patches),
             n_rows_ds_patches_before_calculations)
```

```{r}
#Calculate in each culture when was the time we saw of the protis species
protist_last_saw_columns = paste0(protist_species, "_last_saw_day")

for(culture_ID_input in 1:n_cultures){
  for(protist_input in protist_species){
    
    protist_density_column = paste0(protist_input, "_indiv_per_ml")
    protist_last_saw_column = paste0(protist_input, "_last_saw_day")
    
    day_last_saw = ds_patches %>%
      filter(culture_ID == culture_ID_input) %>%
      select(day,
             all_of(protist_density_column)) %>%
      slice(which.max(.data[[protist_density_column]])) %>%
      pull(day)
    
    ds_patches[[protist_last_saw_column]][ds_patches$culture_ID == culture_ID_input] = day_last_saw
  }
}
```

```{r}
#Reorder columns 
ds_patches = ds_patches %>%
  select(any_of(c(
    columns_patches,
    variables_patches,
    baseline_columns,
    protist_last_saw_columns
  )))
```

```{r}
save(ds_patches, file = here("results", "ds", "ds_patches.RData"))
```
