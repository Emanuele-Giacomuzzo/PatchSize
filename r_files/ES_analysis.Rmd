---
title: "Untitled"
output: html_document
date: "2023-04-14"
editor_options: 
  chunk_output_type: console
---

```{r}
filtered_data = ds_patches_effect_size %>%
  filter(
    time_point >= first_time_point_model,
    time_point <= last_time_point_model,
    patch_type %in% patch_type_input_model
  )
```

```{r}
plot.patches.points.ES(filtered_data,
                       patch_type_input_model,
                       response_variable)
```

- Null model 

```{r}
null_model = lm(get(response_variable) ~
                  1,
                data = filtered_data)

summary(null_model)
par(mfrow = c(2, 3))
plot(null_model, which = 1:5)
```

- Full model (with `size_connected_patch` and `size_connected_patch : day`)

```{r}
full_model = lm(get(response_variable) ~
                  size_connected_patch +
                  size_connected_patch:day,
                data = filtered_data)

summary(full_model)
par(mfrow = c(2, 3))
plot(full_model, which = 1:5)

model_stats_full = compute.model.stats(full_model,
                                       null_model,
                                       "linear_model") %>%
  print()
```

- Interaction model (with `size_connected_patch : day`)

```{r}
interaction_model = lm(get(response_variable) ~
                         size_connected_patch:day,
                       data = filtered_data)

summary(interaction_model)
par(mfrow = c(2, 3))
plot(full_model, which = 1:5)
model_stats_fixed = compute.model.stats(interaction_model,
                                        null_model,
                                        "linear_model") %>%
  print()
```

- Fixed model (with `size_connected_patch`)

```{r}
fixed_model = lm(get(response_variable) ~
                   size_connected_patch,
                 data = filtered_data)

summary(fixed_model)
par(mfrow = c(2, 3))
plot(full_model, which = 1:5)
model_stats_interaction = compute.model.stats(fixed_model,
                                              null_model,
                                              "linear_model") %>%
  print()
```

```{r}
results_table = fill.results.table(
  results_table,
  response_variable,
  patch_type_input_model,
  model_stats_full,
  model_stats_interaction,
  model_stats_fixed
)
```

Let's now see if the model with the intercept is better.

```{r}

for (patch_type_input_model_singular in patch_type_input_model) {
  
  filtered_data = ds_patches_effect_size %>%
    filter(
        time_point >= first_time_point_model,
        time_point <= last_time_point_model,
        patch_type %in% patch_type_input_model_singular
    )
  
  intercept_model = lm(get(response_variable) ~
                         1,
                       data = filtered_data)
  
  summary(intercept_model)
  
  no_intercept_model_2 = lm(get(response_variable) ~
                              0,
                            data = filtered_data)
  
  AIC(intercept_model, no_intercept_model_2) %>%
    print()
  
}
```