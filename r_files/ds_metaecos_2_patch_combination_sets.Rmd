---
title: "Find combination sets for isolated SL / MM systems"
output: html_document
date: "2023-05-19"
editor_options: 
  chunk_output_type: console
---

```{r isolated-SL-systems-combination-sets-create}

#Create sets for SL isolated, where in each set a small and a large patches are paired differently. To do so, I keep the small patches on the same order and perform permutations on large patches.

SL_isolated_sys_sets <- vector("list",
                               length(disturbance_levels))

for (disturbance_i in 1:length(disturbance_levels)) {
  
  ID_small_patches = ds_patches %>%
    filter(disturbance == disturbance_levels[disturbance_i],
           patch_type == "Small isolated") %>%
    pull(culture_ID) %>%
    unique()
  
  ID_large_patches = ds_patches %>%
    filter(disturbance == disturbance_levels[disturbance_i],
           patch_type == "Large isolated") %>%
    pull(culture_ID) %>%
    unique()
  
  #Force small and large patches vectors to have the same length
  length_difference <- length(ID_small_patches) - length(ID_large_patches)
  if (length_difference > 0) {
    
    ID_large_patches = c(ID_large_patches,
                       rep("Patch taken off",
                           times = abs(length(ID_small_patches) - 
                                       length(ID_large_patches))))
    
    } else if (length_difference < 0) {
      
    ID_small_patches = c(ID_small_patches,
                         rep("Patch taken off",
                             times = abs(length(ID_large_patches) - 
                                         length(ID_small_patches))))
    }

  # Create dataframe
  permutations_large = permn(ID_large_patches)
  
  SL_isolated_sys_sets[[disturbance_i]] = data.frame(
    disturbance = disturbance_levels[disturbance_i],
    metaecosystem_type = "Small-Large isolated",
    connection = "isolated",
    ID_first_patch = rep(ID_small_patches, times = length(permutations_large)),
    ID_second_patch = unlist(permutations_large),
    set = rep(1 : length(permutations_large), each = length(ID_small_patches)))
  
  expect_equal(nrow(SL_isolated_sys_sets[[disturbance_i]]),
               length(ID_small_patches) * length(permutations_large))
  
  SL_isolated_sys_sets[[disturbance_i]] = SL_isolated_sys_sets[[disturbance_i]] %>%
    filter(!ID_first_patch == "Patch taken off",
           !ID_second_patch == "Patch taken off") %>%
    mutate(ID_first_patch = as.double(ID_first_patch),
           ID_second_patch = as.double(ID_second_patch)) %>%
    full_join(patch_combinations %>%
                filter(disturbance == disturbance_levels[disturbance_i], 
                       metaecosystem_type == "Small-Large isolated")) #Add system_nr & patches_combined

}

SL_isolated_sys_sets_before_binding = SL_isolated_sys_sets
SL_isolated_sys_sets = SL_isolated_sys_sets %>%
  bind_rows()
```

```{r}
expect_equal(nrow(SL_isolated_sys_sets),
             nrow(SL_isolated_sys_sets_before_binding[[1]]) + nrow(SL_isolated_sys_sets_before_binding[[2]]))

expect_equal(length(SL_isolated_sys_sets %>% 
                      pull(system_nr) %>% 
                      unique()),
             length(patch_combinations %>%
                      filter(metaecosystem_type == "Small-Large isolated") %>%
                      pull(system_nr) %>%
                      unique()))
```

```{r isolated-MM-systems-combination-sets-create}

#WORK HERE

#Create sets for MM isolated, where in each set two medium patches small are paired differently. To do so, I ... 

#Initialise MM_isolated_sets. Assign 10^4 rows to each matrix so that we have enough rows not to run out of them when we try to assign values to them. Assign 4 columns which will include culture_ID of the first system, second culture_ID of the fist system, culture_ID of the second system, and second culture_ID of the second system.  
MM_isolated_sets = NULL
for(disturbance_i in 1:length(disturbance_levels)){
  
  MM_isolated_sets[[disturbance_i]] <- matrix(nrow = 10 ^ 4, 
                                              ncol = 4)
  
}

for (disturbance_i in 1:length(disturbance_levels)) {
  
  ID_medium_patches = ds_patches %>%
    filter(disturbance == disturbance_levels[disturbance_i],
           patch_type == "Medium isolated") %>%
    pull(culture_ID) %>%
    unique()
  
  MM_isolated_systems = combn(ID_medium_patches, 
                              2) %>%
    t()
  
  matrix_row = 0
  for (first_system_i in 1:nrow(MM_isolated_systems)) {
    
    #Find culture IDs of the first system (what's the first system?)
    first_system = MM_isolated_systems[first_system_i, ]
    
    for (second_system_i in 1:nrow(MM_isolated_systems)) {
      
      #Find culture IDs of the second system (what's the second system?)
      second_system = MM_isolated_systems[second_system_i, ]
      
      shared_elements_among_systems = intersect(first_system,
                                                second_system)
      
      if (length(shared_elements_among_systems) == 0) {
        
        matrix_row = matrix_row + 1
        
        #Make first and second system into a set
        MM_isolated_sets[[disturbance_i]][matrix_row,] = c(first_system,
                                                            second_system)
        
        print(MM_isolated_sets[[disturbance_i]][matrix_row,])
        
      }
    }
  }
  
  #Tidy the dataset with all the patch combinations
  MM_isolated_sets[[disturbance_i]] = MM_isolated_sets[[disturbance_i]] %>%
    as.data.frame() %>%
    drop_na()
  
  expect_equal(MM_isolated_sets[[disturbance_i]] %>% 
                 filter(V1 == V2 | V1 == V3 | V1 == V4 | V2 == V3 | V2 == V4 | V3 == V4) %>% 
                 nrow(),
               0)
  
  #Reorder the dataset with all the patch combinations
  MM_isolated_sets_reordered = data.frame(ID_first_patch = NA,
                                          ID_second_patch = NA,
                                          set = NA)
  
  for (set_input in 1:nrow(MM_isolated_sets[[disturbance_i]])) {
    MM_isolated_sets_reordered = MM_isolated_sets_reordered %>%
      add_row(
        ID_first_patch = MM_isolated_sets[[disturbance_i]][set_input, 1],
        ID_second_patch = MM_isolated_sets[[disturbance_i]][set_input, 2],
        set = set_input
      ) %>%
      add_row(
        ID_first_patch = MM_isolated_sets[[disturbance_i]][set_input, 3],
        ID_second_patch = MM_isolated_sets[[disturbance_i]][set_input, 4],
        set = set_input
      )
  }
  
  #Add to a list
  MM_isolated_sets[[disturbance_i]] = MM_isolated_sets_reordered %>%
    drop_na() %>%
    mutate(
      disturbance = disturbance_levels[disturbance_i],
      metaecosystem_type = "Medium-Medium isolated",
      connection = "isolated"
    )
  
  #Add system nr
  ID_combinations_MM_isolated = patch_combinations %>%
    filter(disturbance == disturbance_levels[disturbance_i],
           metaecosystem_type == "Medium-Medium isolated")
  
  MM_isolated_sets[[disturbance_i]] = full_join(MM_isolated_sets[[disturbance_i]],
                                                     ID_combinations_MM_isolated)
  
}

#Bind all sets of MM isolated
MM_isolated_sets = MM_isolated_sets %>%
  bind_rows()
```

```{r}
expect_equal(length(MM_isolated_sets %>%
                      pull(system_nr) %>%
                      unique()),
             length(patch_combinations %>%
                      filter(metaecosystem_type == "Medium-Medium isolated") %>%
                      pull(system_nr) %>%
                      unique()))
```

```{r isolated-systems-combination-sets-join}

#Bind SL and MM isolated systems

isolated_combinations_sets = rbind(SL_isolated_sys_sets, 
                                   MM_isolated_sets) %>%
  select(disturbance,
         metaecosystem_type,
         connection,
         set,
         system_nr,
         ID_first_patch,
         ID_second_patch)
```
